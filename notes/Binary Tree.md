# 简介
BFS：Queue
DFS：Stack

# 面试题分类
## 遍历二叉树
* 二叉树中的遍历（前序遍历，中序遍历，后序遍历）
    * Binary Tree DFS Traversal
    * Binary Tree BFS Traversal
    * Divide & Conquer（Merge Sort、Quick Sort）
        * Divide：对于左右子树分别去同时处理，将原问题划分成为更小的子问题
        * Conquer：将子问题的解合并，返回问题的解
[Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal)  
[Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal)  
[Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal)
* 二叉树的层次遍历（从上往下，从左往右）
[Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal)  
[Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii)  
[Binary Tree Vertical Order Traversal](https://leetcode.com/problems/binary-tree-vertical-order-traversal)  
按之字形遍历二叉树（一正一反）：[Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal)
* Path Sum  
[Path Sum](https://leetcode.com/problems/path-sum)  
[Path Sum II](https://leetcode.com/problems/path-sum-ii)  
[Path Sum III](https://leetcode.com/problems/path-sum-iii)

## 生成二叉树
* 根据遍历序列构建二叉树：
[Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)  
[Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal)
* 根据排序好的数组/链表转换为二叉查找树  
将一个排序好的数组转换为二叉查找树：[Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree)  
将一个排序好的链表转换为二叉查找树：[Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree)
* ：
[Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees)  
[Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii)

## 
* 求二叉树中的节点个数：[Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes)
* 求二叉树第 K 层的节点个数：
* 求二叉树中左叶子节点的个数：[Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves)
* 求二叉树的深度  
二叉树最大深度：[Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree)  
二叉树最小深度[Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree)
* 求二叉树的最大宽度：：[Maximum Width of Binary Tree](https://leetcode.com/problems/maximum-width-of-binary-tree)

* 求二叉树中节点的最大距离：[]()
* 二叉树路径：[Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths)
* 根节点到叶子节点的路径和：[Binary Tree Path Sum]()
* 二叉树的最大路径和：  
[Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum)  
[Binary Tree Maximum Path Sum II](https://leetcode.com/problems/binary-tree-maximum-path-sum-ii)

* 判断两颗二叉树是否完全相同：[Same Tree](https://leetcode.com/problems/same-tree)
* 判断二叉树是不是平衡二叉树：[Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree)
* 判断一个树是否左右对称：[Symmetric Tree](https://leetcode.com/problems/symmetric-tree)
* 求二叉树的镜像（破坏和不破坏原来的树两种情况）：[]()
* 求二叉树中两个节点的最低公共祖先节点：[Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree)
* 判断二叉树是不是完全二叉树：[]()
* 找出二叉树中最长连续子串 (即全部往左的连续节点，或是全部往右的连续节点）：[]()
* 恢复成正确的二叉查找树：[Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree)
* 将二叉查找树变为有序的双向链表：[Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list)
* [Verify Preorder Serialization of a Binary Tree](https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree)
* [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree)
* [Second Minimum Node In a Binary Tree](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree)
* [Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree)
* [Binary Tree Tilt](https://leetcode.com/problems/binary-tree-tilt)
* [Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves)
* [Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree)
* [Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree)
* [Minimum Absolute Difference in BST](https://leetcode.com/problems/minimum-absolute-difference-in-bst)
* [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree)
* [Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree)
* [Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees)
* [Find Mode in Binary Search Tree](https://leetcode.com/problems/find-mode-in-binary-search-tree)

二叉查找树
* [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree)
* [Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree)
* [Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii)  
* [Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree)
* [Closest Binary Search Tree Value](https://leetcode.com/problems/closest-binary-search-tree-value)
* [Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator)
* [Print Binary Tree](https://leetcode.com/problems/print-binary-tree)

# 代码实现
## 二叉树的遍历
* 前序遍历：先根节点，后左节点，最后右节点
* 中序遍历：先左节点，再根节点，最后右节点
* 后序遍历：先左节点，再右节点，最后根节点
* 层序遍历：
### 前序遍历
先放进去 root，然后放进去顶元素的 right，然后放进去 left
#### 非递归
```java
public List<Integer> preorderTraversal(TreeNode root) {
    ArrayList<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    if (root == null) return result;

    stack.push(root);
    while (!stack.empty()) {
        TreeNode cur = stack.pop();
        result.add(cur.val);
        if (cur.right != null) {
            stack.push(cur.right);
        }
        if (cur.left != null) {
            stack.push(cur.left);
        }
    }
    return result;
}
```

#### 递归
```java

```

#### 分治法
```java

```

### 中序遍历
在进入 while 循环之前什么都不错，先把 cur=root。进去之后，首先再用一个 wihle 一直往左走知道尽头，也一路的存入 stack，然后把顶元素存入 result，并且这时候把 cur 变成顶元素的右儿子。
#### 非递归
```java
public List<Integer> inorderTraversal(TreeNode root) {
    ArrayList<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    if (root == null) return result;

    TreeNode cur = root;
    while (cur != null || !stack.empty()) {
        while (cur != null) {
            stack.add(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        result.add(cur.val);
        cur = cur.right;
    }
    return result;
}
```

#### 递归
```java

```

#### 分治法
```java

```

### 后序遍历
首先用一个 cur，和一个 pre。进入之前把 root 存进去。然后，只要是上一个处理的是 null，或者是 pre.left,pre.right 等于现在的 cur，就先把 left 存进去，如果 left 空，存进去 right。然后，如果上一次处理的是当前结点的 left，那么说明该处理右边了，所以把 right 存进去，如果以上两个情况都不是，那么就要存结果了，并且 pop。记住就是最后的时候 pre = cur。
#### 非递归
```java
public List<Integer> postorderTraversal(TreeNode root) {
    ArrayList<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    if (root == null) return result;
    
    TreeNode prev = null; // previously traversed node
    TreeNode cur = root;
    
    stack.push(root);
    while (!stack.empty()) {
        cur = stack.peek();
        if (prev == null || prev.left == cur || prev.right == cur) { // traverse down the tree
            if (cur.left != null) {
                stack.push(cur.left);
            } else if (cur.right != null) {
                stack.push(cur.right);
            }
        } else if (cur.left == prev) { // traverse up the tree from the left
            if (cur.right != null) {
                stack.push(cur.right);
            }
        } else { // traverse up the tree from the right
            result.add(cur.val);
            stack.pop();
        }
        prev = cur;
    }
    return result;
}
```

#### 递归
```java

```

#### 分治法
```java

```

### 层序遍历
#### 非递归
```java

```

#### 递归
```java

```

#### 分治法
```java

```