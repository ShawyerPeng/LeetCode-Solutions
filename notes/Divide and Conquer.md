# 简介
就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题…… 直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法 (快速排序，归并排序)，傅立叶变换 (快速傅立叶变换)……

暴力解法的时间复杂度都是 O(n), 可以用分治法进行优化成 O(logn)，原理就是用分治法批量排除不满足条件的 candidates。

分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

分治策略是：对于一个规模为 n 的问题，若该问题可以容易地解决（比如说规模 n 较小）则直接解决，否则将其分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。

如果原问题可分割成 k 个子问题，1<k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

# 适用的情况
分治法所能解决的问题一般具有以下几个特征：
* 该问题的规模缩小到一定的程度就可以容易地解决
* 该问题可以分解为若干个规模较小的相同问题，即该问题具有**最优子结构**性质。
* 利用该问题分解出的**子问题的解可以合并**为该问题的解；
* 该问题所分解出的**各个子问题相互独立**，即子问题之间不包含公共的子子问题。

第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；
第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；
第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。
第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。

# 实现步骤
1. 分解：将原问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题
2. 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
3. 合并：将各个子问题的解合并为原问题的解

# 代码模板


# 相关题目
sqrt(X) pow(x, n) fastPower

（1）二分搜索
（2）大整数乘法
（3）Strassen 矩阵乘法
（4）棋盘覆盖
（5）合并排序
（6）快速排序
（7）线性时间选择
（8）最接近点对问题
（9）循环赛日程表
（10）汉诺塔

## 169. Majority Element
要求一个 int 容器里面的主元素，题目给定的主元素定义是出现次数超过⌊ n/2 ⌋次，其中 n 即为容器的元素数目。我们的分治思想就是将容器不断拆成无数个小容器，再去这些小容器中比较查找主元素，然后不断回溯上来。

分：把容器均分成容器 A 和容器 B  
治：寻找容器 A 和容器 B 的主元素（在这个过程中，又能对容器 A 和容器 B 进行分治）

这样分治下去肯定有尽头，所以递归的边界条件也就是容器只有一个元素时，直接返回该元素。

回溯的时候的判断：  
如果 A 和 B 的主元素 me 相等，那么主元素就是 me  
如果 A 的主元素是 me1,B 的主元素是 me2，那么重新遍历 A 和 B 还没分之前的那个容器，比较 me1 和 me2 出现的次数，谁次数大，谁来当主元素。  

时间复杂度 T(n)=2T(n/2)+2O(n)=O(nlogn)。

```java

```


# 参考资料
[LeetCode 总结，分治法总结](http://blog.csdn.net/ebowtang/article/details/51218500)  
[leetcode 总结无止境系列之动态规划及比较](http://cuijing.org/2013/07/summary-of-dynamic-programming-in-leetcode/)  
[分治法算法复杂度](https://gaomf.cn/2016/10/25/divide_conquer/)  
[DIVID & CONQUER 本质上是数学归纳法么？](https://www.jiuzhang.com/qa/1249/)  
[TRAVERSE VS DIVIDE-AND-CONQUER](https://www.jiuzhang.com/qa/723/)  
[算法学习 - 最大子数组问题 [Maximum Subarray]](http://yeziahehe.com/2017/09/21/MaximumSubArray/)  
[算法笔记：树和分治 + 复杂度分析 2](http://www.jianshu.com/p/897877b6b9ee)  
